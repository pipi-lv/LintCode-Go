package leetcode

//给定一个正整数 n ，请你统计在 [0, n] 范围的非负整数中，有多少个整数的二进制表示中不存在 连续的 1 。
//
//
//
// 示例 1:
//
//
//输入: n = 5
//输出: 5
//解释:
//下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：
//0 : 0
//1 : 1
//2 : 10
//3 : 11
//4 : 100
//5 : 101
//其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。
//
// 示例 2:
//
//
//输入: n = 1
//输出: 2
//
//
// 示例 3:
//
//
//输入: n = 2
//输出: 3
//
//
//
//
// 提示:
//
//
// 1 <= n <= 10⁹
//
//
// Related Topics 动态规划 👍 382 👎 0

// 因为正整数 n 可以取到 10⁹，所以显然是不可能通过暴力遍历从 1 到 n 的所有正整数来计算答案的。直观上，我们也可以感觉到，在暴力遍历的过程中，有非常多的计算是重复的。因此，我们考虑通过优化暴力遍历来解决这个问题。
// 为了形象地将重复计算的部分找出来，我们不妨将小于等于 n 的非负整数用 01 字典树的形式表示，其中的每一条从根结点到叶结点的路径都是一个小于等于 n 的非负整数（包含前导 0）。
// 于是，题目可以转化为：在由所有小于等于 n 的非负整数构成的 01 字典树中，找出不包含连续 1 的从根结点到叶结点的路径数量。
// 我们在计算不包含连续 1 的从根结点到叶结点的路径数量时，可以不断地将字典树拆分为根结点为 0 的满二叉树和根结点不定的完全二叉树。
// 于是，题目被拆分为以下两个子问题：
// 问题 1：如何计算根结点为 0 的满二叉树中，不包含连续 1 的从根结点到叶结点的路径数量。
// 问题 2：如何将将字典树拆分为根结点为 0 的满二叉树和根结点不定的完全二叉树。
func findIntegers(n int) int {
	// 10^9 ~ 2^30，高度为i-1的以0为根结点的满二叉树不包含连续 1 的从根结点到叶结点的路径数量
	dp := [31]int{1, 1}
	for i := 2; i < 31; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}

	var result int
	for i, pre := 29, 0; i >= 0; i-- {
		val := 1 << i
		if n&val > 0 {
			result += dp[i+1]
			if pre == 1 {
				break
			}
			pre = 1
		} else {
			pre = 0
		}

		if i == 0 {
			result++
		}
	}

	return result
}
